---
title: "Differential expression analysis-2"
author: "Min-Yao"
date: "2025-09-29"
output: html_document
---

```{r}
library(monocle3)

# The tutorial shown below and on subsequent pages uses two additional packages:
library(ggplot2)
library(dplyr)
set.seed(2025)
```

# Finding genes that change as a function of pseudotime

Identifying the genes that change as cells progress along a trajectory is a core objective of this type of analysis. Knowing the order in which genes go on and off can inform new models of development. For example, Sharon and Chawla et al recently analyzed pseudotime-dependent genes to arrive at a whole new model of how islets form in the pancreas.

Let's return to the embryo data, which we processed using the commands

```{r}
expression_matrix <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_expression.rds"))
cell_metadata <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_colData.rds"))
gene_annotation <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_rowData.rds"))
cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
cds <- preprocess_cds(cds, num_dim = 50)
cds <- align_cds(cds, alignment_group = "batch", residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
cds <- reduce_dimension(cds)
plot_cells(cds)
```

> Arguments

cds	
The cell_data_set upon which to perform clustering.

reduction_method	
The dimensionality reduction method upon which to base clustering. Options are "UMAP", "tSNE", "PCA" and "LSI".

k	
Integer number of nearest neighbors to use when creating the k nearest neighbor graph for Louvain/Leiden clustering. k is related to the resolution of the clustering result, a bigger k will result in lower resolution and vice versa. Default is 20.

cluster_method	
String indicating the clustering method to use. Options are "louvain" or "leiden". Default is "leiden". Resolution parameter is ignored if set to "louvain".

num_iter	
Integer number of iterations used for Louvain/Leiden clustering. The clustering result giving the largest modularity score will be used as the final clustering result. Default is 1. Note that if num_iter is greater than 1, the random_seed argument will be ignored for the louvain method.

partition_qval	
Numeric, the q-value cutoff to determine when to partition. Default is 0.05.

weight	
A logical argument to determine whether or not to use Jaccard coefficients for two nearest neighbors (based on the overlapping of their kNN) as the weight used for Louvain clustering. Default is FALSE.

resolution	
Parameter that controls the resolution of clustering. If NULL (Default), the parameter is determined automatically.

random_seed	
The seed used by the random number generator in louvain-igraph package. This argument will be ignored if num_iter is larger than 1.

verbose	
A logic flag to determine whether or not we should print the run details.

nn_control	
An optional list of parameters used to make the nearest neighbor index. See the set_nn_control help for detailed information. The default metric is cosine for reduction_methods PCA, LSI, and Aligned, and is euclidean for reduction_methods tSNE and UMAP.

> Clusters & Partitions

Clusters = fine-grained communities of cells found by Leiden/Louvain on the k-NN graph (think “putatively similar cell types/subtypes”).

Partitions = coarser, well-separated groups of cells (often distinct lineages/components). Monocle learns a separate trajectory graph per partition.

What that means in practice

How they’re made

Clusters: community detection on the cell k-NN graph built from your chosen embedding (UMAP by default). Tuned mainly by k and resolution.

Partitions: Monocle applies a PAGA-style connectivity test to decide which clusters belong to the same “component”. Components become partitions.

How to use them

Use clusters to: find marker genes, annotate cell types, compare subpopulations.

Use partitions to: define separate trajectories. learn_graph() fits a principal graph within each partition. When you order_cells(), you need at least one root per partition, otherwise cells in root-less partitions get infinite pseudotime (shown in grey).

Interpretation tips

If you see many partitions unexpectedly, that can indicate batch effects or overly sparse connectivity; consider align_cds() or adjusting k.

If you want one continuous trajectory across everything, try learn_graph(cds, use_partition = FALSE) (but only if biologically sensible).

```{r}
cds <- cluster_cells(cds)
plot_cells(cds)

cds <- learn_graph(cds)
```


```{r}
cds <- order_cells(cds)

```

```{r}
plot_cells(cds,
           color_cells_by = "cell.type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
```



How do we find the genes that are differentially expressed on the different paths through the trajectory? How do we find the ones that are restricted to the beginning of the trajectory? Or excluded from it?

Once again, we turn to graph_test(), this time passing it neighbor_graph="principal_graph", which tells it to test whether cells at similar positions on the trajectory have correlated expression:

```{r}
ciliated_cds_pr_test_res <- graph_test(cds, neighbor_graph="principal_graph", cores=1)
pr_deg_ids <- row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))
```

Here are a couple of interesting genes that score as highly significant according to graph_test():

```{r}
plot_cells(cds, genes=c("hlh-4", "gcy-8", "dac-1", "oig-8"),
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE)
```

As before, we can collect the trajectory-variable genes into modules:

```{r}
gene_module_df <- find_gene_modules(cds[pr_deg_ids,], resolution=c(10^seq(-6,-1)))
```

Here we plot the aggregate module scores within each group of cell types as annotated by Packer & Zhu et al:

```{r}
cell_group_df <- tibble::tibble(cell=row.names(colData(cds)), 
                                cell_group=colData(cds)$cell.type)
agg_mat <- aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat,
                   scale="column", clustering_method="ward.D2")
```

We can also pass gene_module_df to plot_cells() as we did when we compared clusters in the L2 data above.

```{r}
plot_cells(cds,
           genes=gene_module_df %>% filter(module %in% c(27, 10, 7, 30)),
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
```

Monocle offers another plotting function that can sometimes give a clearer view of a gene's dynamics along a single path. You can select a path with choose_cells() or by subsetting the cell data set by cluster, cell type, or other annotation that's restricted to the path. Let's pick one such path, the AFD cells:

```{r}
AFD_genes <- c("gcy-8", "dac-1", "oig-8")
AFD_lineage_cds <- cds[rowData(cds)$gene_short_name %in% AFD_genes,
                       colData(cds)$cell.type %in% c("AFD")]
AFD_lineage_cds <- order_cells(AFD_lineage_cds)
```

The function plot_genes_in_pseudotime() takes a small set of genes and shows you their dynamics as a function of pseudotime:

```{r}
plot_genes_in_pseudotime(AFD_lineage_cds,
                         color_cells_by="embryo.time.bin",
                         min_expr=0.5)
```

You can see that dac-1 is activated before the other two genes.