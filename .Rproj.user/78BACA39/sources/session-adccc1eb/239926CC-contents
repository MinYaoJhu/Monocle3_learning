---
title: "Calculating Trajectories with Monocle 3 and Seurat"
author: "Min-Yao"
date: "2025-09-28"
output: 
  html_document: 
    keep_md: true
---

This vigettte demonstrates how to run trajectory inference and pseudotime calculations with Monocle 3 on Seurat objects. If you use Monocle 3, please cite:

The single-cell transcriptional landscape of mammalian organogenesis

Junyue Cao, Malte Spielmann, Xiaojie Qiu, Xingfan Huang, Daniel M. Ibrahim, Andrew J. Hill, Fan Zhang, Stefan Mundlos, Lena Christiansen, Frank J. Steemers, Cole Trapnell & Jay Shendure

doi: 10.1038/s41586-019-0969-x

Website: https://cole-trapnell-lab.github.io/monocle3/

Prerequisites to install:

Seurat
SeuratWrappers
SeuratData
Monocle 3

```{r}
library(monocle3)
library(Seurat)
library(SeuratObject)
library(SeuratData)
library(SeuratWrappers)
library(SingleCellExperiment)
library(ggplot2)
library(patchwork)
library(magrittr)

set.seed(2025)  # make UMAP/graphs reproducible
```

# HCA Bone Marrow 40k

```{r}
#InstallData("hcabm40k")

# install.packages(
#   "D:/Oldroyd_lab/GitHub/Monocle3_learning/hcabm40k.SeuratData_3.0.0.tar.gz",
#   repos = NULL,
#   type = "source"
# )
library(hcabm40k.SeuratData)
data("hcabm40k")
```

```{r}
# 1) Bring the dataset up to your installed Seurat/SeuratObject schema
hcabm40k <- SeuratObject::UpdateSeuratObject(hcabm40k)

# (optional but helpful) Slim the object and drop legacy stuff that can confuse later steps
hcabm40k <- DietSeurat(
  hcabm40k,
  assays    = DefaultAssay(hcabm40k),
  dimreducs = NULL,
  graphs    = NULL
)

# sanity checks
DefaultAssay(hcabm40k)
head(hcabm40k$orig.ident)
```


```{r}
# ---- Split by dataset of origin (acts like 'batches') ----
# Splitting lets us normalize / find HVGs per dataset before integration.
hcabm40k <- SplitObject(hcabm40k, split.by = "orig.ident")

# ---- Normalize + select HVGs per split (anchor-friendly) ----
for (i in seq_along(hcabm40k)) {
    hcabm40k[[i]] <- NormalizeData(hcabm40k[[i]]) %>% FindVariableFeatures()
}

# ---- Pick a common feature set used to compute anchors ----
features <- SelectIntegrationFeatures(hcabm40k)

# ---- Scale + PCA per split on the *same* features ----
# Using the same features across splits makes RPCA anchors more stable.
for (i in seq_along(along.with = hcabm40k)) {
    hcabm40k[[i]] <- ScaleData(hcabm40k[[i]], features = features) %>% RunPCA(features = features)
}
```

```{r}
# ---- Find anchors and integrate (RPCA-based integration) ----
# RPCA is faster/more robust on large datasets than CCA in many cases.
anchors <- FindIntegrationAnchors(
  hcabm40k,
  reference = c(1, 2),
  reduction = "rpca",
  dims = 1:30
)


integrated <- IntegrateData(anchors, dims = 1:30)
```

```{r}
# ---- Post-integration: scale, reduce, and cluster ----
# Standard Seurat pipeline on the integrated assay.
integrated <- ScaleData(integrated)
integrated <- RunPCA(integrated)
integrated <- RunUMAP(integrated, dims = 1:30, reduction.name = "UMAP")
integrated <- FindNeighbors(integrated, dims = 1:30)
integrated <- FindClusters(integrated)

DimPlot(integrated, group.by = c("orig.ident", "ident"))
```

```{r}
# ------------------------------------------------
# 1) Convert Seurat -> Monocle (once), get partitions
# ------------------------------------------------
cds <- as.cell_data_set(integrated)
# computes kNN graph + clusters + partitions
cds <- cluster_cells(cds) 

# Quick look at partitions (often correspond to distinct lineages)
p1 <- plot_cells(cds, show_trajectory_graph = FALSE)
p2 <- plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE)
p1 + p2
```

```{r}
# 1) Get cell IDs for partition 1 from Monocle
cells_in_p1 <- names(partitions(cds)[partitions(cds) == 1])

# Keep only cells present in the Seurat object too (safety)
cells_in_p1 <- intersect(cells_in_p1, colnames(integrated))
stopifnot(length(cells_in_p1) > 0)
```

```{r}
# 2) Subset the Seurat object to the same cells
integrated.sub <- subset(integrated, cells = cells_in_p1)
```

```{r}
# 3) Build a fresh Monocle cds **from RNA assay** (ensures counts are present)
DefaultAssay(integrated.sub) <- "RNA"
cds <- SeuratWrappers::as.cell_data_set(integrated.sub, assay = "RNA")
summary(cds)
```

```{r}
# Optional: drop all-zero genes in this subset
cds <- cds[rowSums(SingleCellExperiment::counts(cds)) > 0, ]
summary(cds)
```

```{r}
# 4) Recompute everything on the subset (prevents stale-slot errors)
cds <- preprocess_cds(cds, num_dim = 50)
cds <- reduce_dimension(cds, umap.fast_sgd = TRUE, cores = 1)  # cores=1 for Windows
cds <- cluster_cells(cds)
cds <- learn_graph(cds)
plot_cells(
  cds,
  label_groups_by_cluster = FALSE,
  label_leaves = FALSE,
  label_branch_points = FALSE
)
```

```{r}
# 5) Pick a root cell programmatically (highest AVP expression in this subset)
if (!"AVP" %in% rownames(integrated.sub)) {
  stop("Gene 'AVP' not found in integrated.sub; choose another early marker.")
}
max_avp   <- which.max(FetchData(integrated.sub, vars = "AVP")[[1]])
root_cell <- colnames(integrated.sub)[max_avp]
stopifnot(root_cell %in% colnames(cds))
```

```{r}
# 6) Order cells (no GUI) and plot pseudotime
cds <- order_cells(cds, root_cells = root_cell)

plot_cells(
  cds,
  color_cells_by      = "pseudotime",
  label_cell_groups   = FALSE,
  label_leaves        = FALSE,
  label_branch_points = FALSE
)
```

```{r}
# 7) Bring pseudotime back to Seurat and plot (robust + minimal edits)

library(igraph)  # needed only if we fall back to node-based rooting

# 1) try to get pseudotime directly
pt <- tryCatch(monocle3::pseudotime(cds), error = function(e) NULL)

# 2) if pseudotime isn't there, re-order by the nearest principal-graph node
if (is.null(pt) || length(pt) == 0) {
  aux_keys  <- names(cds@principal_graph_aux)
  graph_key <- if ("UMAP" %in% aux_keys) "UMAP" else aux_keys[1]

  # map your existing `root_cell` to its nearest node
  cv <- cds@principal_graph_aux[[graph_key]]$pr_graph_cell_proj_closest_vertex
  cv <- as.matrix(cv[colnames(cds), , drop = FALSE])
  nearest_id <- cv[root_cell, 1]

  node_names   <- igraph::V(principal_graph(cds)[[graph_key]])$name
  root_pr_node <- if (suppressWarnings(!is.na(as.numeric(nearest_id)))) {
    node_names[as.numeric(nearest_id)]
  } else {
    as.character(nearest_id)
  }

  cds <- order_cells(cds, root_pr_nodes = root_pr_node)
  pt  <- monocle3::pseudotime(cds)
}

# 3) align to Seurat cells and add as metadata
pt <- as.numeric(pt)
names(pt) <- colnames(cds)
pt <- pt[Cells(integrated.sub)]
pt[is.infinite(pt)] <- NA_real_
stopifnot(length(pt) == ncol(integrated.sub))

integrated.sub <- AddMetaData(
  integrated.sub,
  metadata = pt,
  col.name = "monocle3_pseudotime"
)

# 4) plot
FeaturePlot(
  integrated.sub,
  features  = "monocle3_pseudotime",
  reduction = "UMAP",
  cols      = c("grey90", "royalblue")
)


```

