---
title: "1_Clustering_and_classifying_your_cells-2"
author: "Min-Yao"
date: "2025-09-29"
output: html_document
---

```{r}
library(monocle3)

# The tutorial shown below and on subsequent pages uses two additional packages:
library(ggplot2)
library(dplyr)
set.seed(2025)
```

```{r}
cds_subset <- readRDS("1_cds_subset.rds")
cds <- load_monocle_objects("1_cds")

# If needed, rebuild minimal state (safe on Windows: cores = 1)
if (is.null(SingleCellExperiment::reducedDims(cds_subset)$UMAP)) {
  cds_subset <- preprocess_cds(cds_subset, num_dim = 50)
  cds_subset <- reduce_dimension(cds_subset, umap.fast_sgd = TRUE, cores = 1)
  cds_subset <- cluster_cells(cds_subset)
}
```


```{r}
# (optional sanity check)
ncol(cds_subset); nrow(cds_subset)
```

Now we have a smaller cell_data_set object that contains just the cells from the partition we'd like to drill into. We can use graph_test() to identify genes that are differentially expressed in different subsets of cells from this partition:

```{r}
ncol(cds_subset)
```

```{r}
pr_graph_test_res <- graph_test(cds_subset, neighbor_graph="knn", cores=1)
pr_deg_ids <- row.names(subset(pr_graph_test_res, morans_I > 0.01 & q_value < 0.05))
```

We will learn more about graph_test() in the differential expression analysis section later. We can take all the genes that vary across this set of cells and group those that have similar patterns of expression into modules

```{r}
gene_module_df <- find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-3)
```

Plotting these modules' aggregate expression values reveals which cells express which modues.

```{r}
plot_cells(cds_subset, genes=gene_module_df, 
           show_trajectory_graph=FALSE, 
           label_cell_groups=FALSE)
```

You can explore the genes in each module or conduct gene ontology enrichment analysis on them to glean insights about which cell types are present. Suppose after doing this we have a good idea of what the cell types in the partition are. Let's recluster the cells at finer resolution and then see how they overlap with the clusters in the partition:

```{r}
cds_subset <- cluster_cells(cds_subset, resolution=1e-2)
plot_cells(cds_subset, color_cells_by="cluster")
```

Based on how the patterns line up, we'll make the following assignments:

```{r}
colData(cds_subset)$assigned_cell_type <- as.character(clusters(cds_subset)[colnames(cds_subset)])
colData(cds_subset)$assigned_cell_type <- dplyr::recode(
  colData(cds_subset)$assigned_cell_type,
  "1" = "Sex myoblasts",
  "2" = "Somatic gonad precursors",
  "3" = "Vulval precursors",
  "4" = "Sex myoblasts",
  "5" = "Vulval precursors",
  "6" = "Somatic gonad precursors",
  "7" = "Sex myoblasts",
  "8" = "Sex myoblasts",
  "9" = "Ciliated neurons",
  "10" = "Vulval precursors",
  "11" = "Somatic gonad precursor",
  "12" = "Distal tip cells",
  "13" = "Somatic gonad precursor",
  "14" = "Sex myoblasts",
  "15" = "Vulval precursors"
)

plot_cells(cds_subset, group_cells_by = "cluster", color_cells_by="assigned_cell_type")
```

Now we can transfer the annotations from the cds_subset object back to the full dataset. We'll also filter out low-quality cells at this stage

```{r}
colData(cds)[colnames(cds_subset),]$assigned_cell_type <- colData(cds_subset)$assigned_cell_type
cds <- cds[,colData(cds)$assigned_cell_type != "Failed QC" | is.na(colData(cds)$assigned_cell_type )]
plot_cells(cds, group_cells_by="partition", 
           color_cells_by="assigned_cell_type", 
           labels_per_group=5)
```

## Automated annotation with Garnett

The above process for manually annotating cells by type can be laborious, and must be re-done if the underlying cluster changes. We recently developed Garnett, a software toolkit for automatically annotating cells. Garnett classifies cells based on marker genes. If you've gone through the trouble of annotated your cells manually, Monocle can generate a file of marker genes that can be used with Garnett. This will help you annotate other datasets in the future or reannotate this one if you refine your analysis and update your clustering in the future.

To generate a Garnett file, first find the top markers that each annotated cell type expresses:

```{r}
assigned_type_marker_test_res <- top_markers(cds,
                                             group_cells_by="assigned_cell_type",
                                             reference_cells=1000,
                                             cores=1)
```

Next, filter these markers according to how stringent you want to be:

```{r}
# Require that markers have at least JS specificty score > 0.5 and
# be significant in the logistic test for identifying their cell type:
garnett_markers <- assigned_type_marker_test_res %>%
                        filter(marker_test_q_value < 0.01 & specificity >= 0.5) %>%
                        group_by(cell_group) %>%
                        top_n(5, marker_score)
# Exclude genes that are good markers for more than one cell type:
garnett_markers <- garnett_markers %>% 
                        group_by(gene_short_name) %>%
                        filter(n() == 1)
```

Then call generate_garnett_marker_file:

```{r}
generate_garnett_marker_file(garnett_markers, file="./marker_file.txt")
```

The marker files produced by generate_garnett_marker_file() are just a starting point for classifying your cells with Garnett. You may want to edit this file to add or remove markers based on literature or other information. You also should consider defining subtypes of cells, which can greatly increase the usefulness and accuracy of Garnett. For example, the L2 data contains many different types of neurons. Making a "Neuron" cell type in the file above and then using the subtype of keyword to organize the various subtypes of neurons will make Garnett more able to recognize them and distinguish them from non-neuronal cell types. When two or more of your cell types share most of their top markers in plot_genes_by_group(), consider defining a broader cell type definition of which they are both subtypes. You might also want to define markers for the various subtypes of neurons by subsetting the cds object above and running top_markers() just on them. See the Garnett documentation for more on how you can enrich your marker files.

When you're ready run Garnett, load the package: